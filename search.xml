<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sdk</title>
      <link href="/2024/05/04/sdk/"/>
      <url>/2024/05/04/sdk/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SDK？"><a href="#什么是SDK？" class="headerlink" title="什么是SDK？"></a>什么是SDK？</h1><p>software development kit 软件开发包</p><h1 id="什么场景下需要-SDK"><a href="#什么场景下需要-SDK" class="headerlink" title="什么场景下需要 SDK ?"></a>什么场景下需要 SDK ?</h1><table><tr><td bgcolor=#FFFFCD><ol><li>平台扩展性: 如果你希望你的应用程序或平台能够被其他开发者扩展或定制，提供一个SDK可以让开发者更容易地与你的平台进行集成。</li><li>降低开发门槛: 通过提供SDK，你可以帮助其他开发者更快速地开始使用你的服务或产品，从而提高了用户的采用率。</li><li>版本控制: 当你的产品或服务有更新时，你可以通过更新SDK来确保集成方能够平滑过渡，而不会因为API的变动导致应用崩溃。</li><li>快速原型开发: 使用SDK可以让开发者们快速构建原型，从而在短时间内验证概念和想法。</li><li>跨平台支持: 通过提供多个SDK版本，可以让开发者在不同平台上使用你的服务，比如移动端、桌面端或者Web端。</li><li>提高安全性: 通过提供SDK，你可以控制与你的服务进行通信的方式和权限，从而保证数据的安全性。</li><li>支持开发生态系统: 提供SDK可以帮助你建立一个强大的开发者生态系统，吸引更多的开发者和合作伙伴。<br>比如,我就一个地方需要使用,我需要单独拿出来封装成 sdk 吗? 当然也不一定. 如果当然拥有 sdk 能让大家忽略具体实现能更快的进入到开发,更新的时候只需要换一下引入的模板就好了</li></ol></td></tr></table><h1 id="SDK-和-starter-的区别与联系"><a href="#SDK-和-starter-的区别与联系" class="headerlink" title="SDK 和 starter 的区别与联系"></a>SDK 和 starter 的区别与联系</h1><table><tr><td bgcolor=#FFFFCD><h2 id="SDK（Software-Development-Kit）"><a href="#SDK（Software-Development-Kit）" class="headerlink" title="SDK（Software Development Kit）"></a>SDK（Software Development Kit）</h2><ul><li><p>定义：SDK是一组开发工具、库、文档等的集合，旨在帮助开发者更容易地构建应用程序、组件或服务。SDK通常包括了一系列的API（Application Programming Interface）和工具，使得开发者能够与特定平台、系统或服务进行交互。</p></li><li><p>用途：</p><ul><li><p>提供了对特定平台、系统或服务的访问和控制。</p></li><li><p>简化了开发者与目标平台之间的交互过程。</p></li><li><p>提供了示例代码、文档等，以便开发者更容易上手。</p></li></ul></li><li><p>示例：Android SDK用于开发Android应用程序，AWS SDK用于与Amazon Web Services进行交互。</p></li></ul><h2 id="Starter"><a href="#Starter" class="headerlink" title="Starter"></a>Starter</h2><ul><li><p>定义：Starter是Spring Boot框架的一部分，它是一种特殊类型的依赖库（Dependency）或模块，用于快速配置和引导特定功能或服务。Starter包含了所需的库、配置和其他依赖，可以帮助开发者轻松地集成特定功能到Spring Boot应用中。</p></li><li><p>用途：</p><ul><li><p>简化了特定功能的集成和配置过程。</p></li><li><p>提供了默认配置，使得开发者可以快速启动项目。</p></li><li><p>减少了对第三方库的繁琐配置。</p></li></ul></li><li><p>示例：Spring Boot提供了许多starter，比如spring-boot-starter-web用于快速搭建Web应用，spring-boot-starter-data-jpa用于集成持久化。</p></li></ul><h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><ul><li><p>角色不同：</p><ul><li><p>SDK是一组工具和API，用于开发者构建应用程序，与特定的平台、系统或服务交互。</p></li><li><p>Starter是Spring Boot框架提供的一种依赖库，用于快速配置和引导特定功能或服务。</p></li></ul></li><li><p>应用场景：</p><ul><li><p>使用SDK可以与特定的平台或服务进行交互，如操作系统、云服务等。</p></li><li><p>使用Starter可以快速集成特定功能，比如Web开发、数据持久化等。</p></li></ul></li><li><p>联系：</p><ul><li>在实际开发中，可以同时使用SDK和Starter来加速开发过程。比如，使用特定SDK与外部服务通信，同时使用Spring Boot Starter来快速构建应用程序。</li></ul></li></ul></td></tr></table><h1 id="开发中常见的-SDK"><a href="#开发中常见的-SDK" class="headerlink" title="开发中常见的 SDK"></a>开发中常见的 SDK</h1><table><tr><td bgcolor=#FFFFCD><ul><li><p>调用第三方 API：在开发过程中，经常会需要与第三方服务进行交互，比如支付接口、社交平台API等。使用相应的SDK可以简化与这些服务进行通信的过程。</p></li><li><p>内部不同系统 HTTP Client 频繁调用封装：在一个大型系统中，可能会涉及到多个内部子系统的通信。为了简化这些子系统之间的HTTP请求，可以封装一个SDK，提供一些常用的HTTP请求方法，让开发者可以更方便地进行调用。</p></li><li><p>中台系统：中台系统通常是一个统一的服务层，为前后端提供接口和服务，也可能会提供一些SDK给前端或其他子系统使用，以便更方便地调用中台的功能。</p></li></ul></td></tr></table><p>工具包算是 sdk 吗 ?</p><table><tr><td bgcolor=#FFFFCD><p>工具包通常包含一系列的库、模块或工具集，用于解决特定领域或问题，以便开发人员能够更快速、高效地完成特定任务。这些工具包可以涵盖各种功能，例如数据处理、网络通信、安全加密、图形处理等。</p><p>因此，从某种意义上说，工具包可以被视为是一种特定领域的SDK，其目的是为了帮助开发人员在特定领域内开发应用程序。</p></td></tr></table><h1 id="SDK开发实战–API客户端SDK开发"><a href="#SDK开发实战–API客户端SDK开发" class="headerlink" title="SDK开发实战–API客户端SDK开发"></a>SDK开发实战–API客户端SDK开发</h1><p>初始化，环境依赖（一定要移除build）</p><p>spring-boot-configuration-processor 的作用是自动生成配置的代码提示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写配置类（启动类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//@Configuration将该类标记为一个配置类，告诉Sping这是一个用于配置的类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan注解用于自动扫描组件，使得水平能够自动注册相应的Bean</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties读取yml中的配置， 设置到我们的属性中，并加上zsapi.client前缀</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;zsapi.client&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZsApiClientConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="comment">//创建一个名为“zsApiClient”的Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ZsApiClient <span class="title function_">zsApiClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZsApiClient</span>(accessKey, secretKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开发com&#x2F;zs&#x2F;zsclientsdk&#x2F;client&#x2F;ZsApiClient.java 调用客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责调用第三方接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZsApiClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GATEWAY_HPST</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8090&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String  accessKey;</span><br><span class="line">    <span class="keyword">private</span> String  secretKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZsApiClient</span><span class="params">(String accessKey, String secretKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessKey = accessKey;</span><br><span class="line">        <span class="built_in">this</span>.secretKey = secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用get方法从服务器获取名称</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getNameByGet</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="comment">//可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中</span></span><br><span class="line">            HashMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//将‘name’参数添加到映射中</span></span><br><span class="line">            paramMap.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">            <span class="comment">//使用httputil工具发起GET请求， 并且获取服务器返回的结果</span></span><br><span class="line">            String result= HttpUtil.get(GATEWAY_HPST + <span class="string">&quot;/api/name/get&quot;</span>, paramMap);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//使用post方法从服务器获取名称</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getNameByPost</span><span class="params">( String name)</span>&#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            paramMap.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">            String result= HttpUtil.post(GATEWAY_HPST + <span class="string">&quot;/api/name/post&quot;</span>, paramMap);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; <span class="title function_">getHeaderMap</span><span class="params">(String body)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个新的HashMap对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将ak, sk和其对应的值放入到map当中。</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;accessKey&quot;</span>, accessKey);</span><br><span class="line">        <span class="comment">//不能直接发送密钥。</span></span><br><span class="line">       <span class="comment">// hashMap.put(&quot;secretKey&quot;, secretKey);</span></span><br><span class="line">        <span class="comment">//生成随机数</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//请求体内容</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;body&quot;</span>, body);</span><br><span class="line">        <span class="comment">//String.valueOf将数值转换为字符串</span></span><br><span class="line">        <span class="comment">//String.currentTimeMillis反悔呢当前的时间的毫秒数/1000转成秒</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;timestamp&quot;</span>, String.valueOf(System.currentTimeMillis()/<span class="number">1000</span>));</span><br><span class="line">        hashMap.put(<span class="string">&quot;sign&quot;</span>, genSign(body, secretKey));</span><br><span class="line">        <span class="comment">//返回请求头的map</span></span><br><span class="line">        <span class="keyword">return</span> hashMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用post方法向服务器发送User对象，并且获取服务器返回的结果</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getUserNameByPost</span><span class="params">( User user)</span>&#123;</span><br><span class="line">            <span class="comment">//将user对象转成字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(user);</span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(GATEWAY_HPST + <span class="string">&quot;/api/name/userpost&quot;</span>)</span><br><span class="line">                    <span class="comment">//添加前面构造的请求头</span></span><br><span class="line">                    .addHeaders(getHeaderMap(json))</span><br><span class="line">                    .body(json)<span class="comment">//将JSON字符串设置为请求体</span></span><br><span class="line">                    .execute();<span class="comment">//执行请求</span></span><br><span class="line">            System.out.println(httpResponse.getStatus());</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> httpResponse.body();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>签名工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 签名工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">genSign</span><span class="params">(String body, String secretKey)</span>&#123;</span><br><span class="line">       <span class="comment">//使用SHA256算法生成的Digester</span></span><br><span class="line">        <span class="type">Digester</span> <span class="variable">md5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digester</span>(DigestAlgorithm.SHA256);</span><br><span class="line">        <span class="comment">//构建签名内容， 将哈希表映射转成为字符串并且拼接密钥</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> body + <span class="string">&quot;.&quot;</span> + secretKey;</span><br><span class="line">        <span class="comment">//计算签名的摘要并返回摘要的16进制表示格式</span></span><br><span class="line">        <span class="keyword">return</span> md5.digestHex(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类 User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>   String username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册配置类–  META-INF&#x2F;spring.factories文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#spring.factories</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration =com.zs.zsclientsdk.ZsApiClientConfig</span><br></pre></td></tr></table></figure><p>maven install 打包代码为本地依赖包–在本地的maven仓库中存储</p><p>在别的项目中引入SDK即可</p>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API签名认证的实现</title>
      <link href="/2024/05/04/API-qmrz/"/>
      <url>/2024/05/04/API-qmrz/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是API签名认证？"><a href="#什么是API签名认证？" class="headerlink" title="什么是API签名认证？"></a>什么是API签名认证？</h1><ul><li>用于验证API请求的安全机制</li><li>作用<ul><li>确保只有经过授权的用户或应用程序能访问API</li><li>防止未经过授权的访问和数据篡改</li><li>适用于无需登录态的场景。只认签名，不关注用户登录态</li></ul></li></ul><h1 id="如何实现API签名认证？"><a href="#如何实现API签名认证？" class="headerlink" title="如何实现API签名认证？"></a>如何实现API签名认证？</h1><table><tr><td bgcolor=#FFFFCD><ul><li>签名认证的本质：<ul><li>签发签名</li><li>使用签名（校验签名）</li></ul></li></ul></td></tr></table><h2 id="API签名认证的参数"><a href="#API签名认证的参数" class="headerlink" title="API签名认证的参数"></a>API签名认证的参数</h2><p>我们这里只做基本的参数说明，API签名认证是一个很灵活的设计，具体要有哪些参数、参数名如何一定要根据场景来。（比如userid， appid， version，固定值等 ）</p><ol><li><p>用户标识 accessKey–调用的识别userA， userB（复杂、无需、无规则）</p></li><li><p>密钥 secretKey–密钥（复杂、无序、无规则） 不能传递给后端❗–前端的东西不可信兄弟们，防止被拦截</p></li></ol><p>（ak， sk类似于用户名和密码，区别是：sk， sk是无状态的）</p><ol start="3"><li><p>用户请求参数</p></li><li><p>签名 sign</p></li><li><p>nonce 随机数 ，只能用一次，服务端要保存用过的随机数</p></li><li><p>时间戳 timeStamp， 检验时间戳是否过期，定时删除随机数。</p></li></ol><h2 id="API实现流程思想"><a href="#API实现流程思想" class="headerlink" title="API实现流程思想"></a>API实现流程思想</h2><ol><li><p>为每个注册的用户随机生成他们的ak，sk，客户端准备请求：客户端构建API请求，并收集所有必要的参数，如请求方法、URL、时间戳、身份凭证等。</p></li><li><p>计算签名：使用特定的加密算法（如HMAC-SHA1、HMAC-SHA256等）对待签名字符串进行加密，生成签名。</p></li><li><p>发送请求：将生成的签名添加到API请求中的特定位置（如请求头或请求参数）。</p></li><li><p>服务器端验证签名：服务器端收到请求后，会使用相同的算法和密钥对接收到的参数进行签名计算。然后将服务器端计算得到的签名与请求中的签名进行比对，如果一致，则验证通过；否则，验证失败。</p></li></ol><h1 id="小知识-对称加密、非对称加密和单向加密"><a href="#小知识-对称加密、非对称加密和单向加密" class="headerlink" title="小知识-对称加密、非对称加密和单向加密"></a>小知识-对称加密、非对称加密和单向加密</h1><ol><li>对称加密</li></ol><ul><li>对称加密使用相同的密钥对数据进行加解密</li><li>发送方和接收方必须事先共享密钥，否则无法进行加解密</li><li>常见的对称加密算法：DES、3DES、AES 等</li><li>适用场景：适用于数据传输量较大、安全性要求不是特别高的场景</li></ul><ol start="2"><li>非对称加密</li></ol><ul><li>非对称加密则使用一对不同的密钥进行加解密，分别称为公钥和私钥</li><li>公钥可以公开，任何人都可以使用它对数据进行加密</li><li>私钥只能由密钥持有人保管，并用于解密数据</li><li>常见的非对称加密算法：RSA、DSA 等</li><li>适用场景：适用于对数据安全性要求较高的场景，例如数字签名、身份认证等</li></ul><ol start="3"><li>单向加密</li></ol><ul><li>只能对数据进行加密，而无法逆向解密回原始数据</li><li>举例：哈希函数<ul><li>相同的输入始终产生相同的哈希值</li><li>即使输入数据发生微小变化，哈希值也会发生巨大变化</li><li>无法从哈希值推导出原始输入数据</li><li>MD5、SHA-256 加密算法也是单向加密</li></ul></li></ul><table><tr><td bgcolor=#FFFFCD><p>举个例子，常见的哈希函数是 MD5 和 SHA-256。假设我们对字符串 “Hello, World!” 进行 MD5 哈希，得到的哈希值是 “65a8e27d8879283831b664bd8b7f0ad4”。无论我们多少次对这个字符串进行 MD5 哈希运算，都会得到相同的哈希值。但是，如果我们只知道哈希值 “65a8e27d8879283831b664bd8b7f0ad4”，是无法确定原始的字符串是 “Hello, World!” 的。</p></td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API签名认证， 项目笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习路线</title>
      <link href="/2024/05/03/czxtxxlx/"/>
      <url>/2024/05/03/czxtxxlx/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>  操作系统的学习侧重于理论，主要分为六大部分:基本概念、进程管理、内存管理、文件管理、磁盘管理、设备管理。其中，最重要 的是进程管理和内存管理。这两部分和我们编写程序相关(比如并发编程、死锁、内存分配)，因此也是面试时的高频考点。</p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><ul><li><p>操作系统的作用</p></li><li><p>操作系统的体系结构</p><ul><li>内核概念</li></ul></li><li><p>处理器状态</p><ul><li>用户态</li><li>核心态</li></ul></li><li><p>系统调用</p></li><li><p>中断和异常</p></li></ul><h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h1><ul><li><p>进程与线程</p><ul><li><p>基本概念</p></li><li><p>进程&#x2F;线程状态及转换</p></li></ul></li><li><p>CPU 进程调度算法</p><ul><li><p>先来先服务(FCFS)</p></li><li><p>短作业优先(SJF)</p></li><li><p>最短剩余时间优先(SRTN)</p></li><li><p>高响应比优先(HRRN)</p></li><li><p>时间片轮转</p></li><li><p>优先级调度</p></li><li><p>多级反馈队列</p></li></ul></li><li><p>进程同步与互斥</p><ul><li><p>信号量机制</p></li><li><p>生产者-消费者模型</p></li><li><p>读者-写者问题</p></li><li><p>哲学家进餐问题</p></li></ul></li><li><p>进程通讯机制。</p><ul><li><p>死锁。</p></li><li><p>死锁产生的条件</p></li><li><p>死锁预防与避免</p></li><li><p>死锁检测与恢复</p></li></ul></li></ul><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h1><ul><li><p>基本概念</p><ul><li><p>内存</p></li><li><p>内存管理</p></li><li><p>地址空间</p></li></ul></li><li><p>覆盖与交换</p></li><li><p>内存分配与回收</p><ul><li><p>连续内存分配</p><ul><li><p>单一连续分配</p></li><li><p>内存碎片</p></li><li><p>分区</p><ul><li><p>固定分区分配</p></li><li><p>动态分区分配</p></li></ul></li></ul></li><li><p>非连续内存分配</p><ul><li><p>分段存储管理</p></li><li><p>分页存储管理</p></li><li><p>页表</p></li><li><p>二级页表</p></li><li><p>多级页表</p></li><li><p>反向页表</p></li><li><p>地址变换机构</p><ul><li><p>基本</p></li><li><p>基于快表</p></li></ul></li><li><p>段页式存储管理</p></li></ul></li><li><p>虚拟内存（非连续内存分配）</p><ul><li><p>基本概念</p></li><li><p>局部性原理</p></li><li><p>实现</p><ul><li><p>请求分段存储管理</p></li><li><p>请求分页存储管理</p></li><li><p>请求段页式存储管理</p></li></ul></li><li><p>页面置换算法</p><ul><li><p>最佳置换算法（OPT，理想置换算法）</p></li><li><p>先进先出置换算法（FIFO）</p></li><li><p>最近最久未使用置换算法（LRU）</p></li><li><p>时钟置换算法（CLOCK）</p></li><li><p>第二次机会算法</p></li></ul></li><li><p>页面分配策略</p></li></ul></li></ul></li></ul><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4.文件管理"></a>4.文件管理</h1><ul><li><p>基本概念</p><ul><li><p>文件系统</p></li><li><p>文件</p><ul><li><p>逻辑结构</p></li><li><p>物理结构</p></li></ul></li><li><p>目录</p></li><li><p>文件描述符</p></li></ul></li><li><p>文件操作</p></li></ul><h1 id="5-磁盘管理"><a href="#5-磁盘管理" class="headerlink" title="5.磁盘管理"></a>5.磁盘管理</h1><ul><li><p>磁盘结构</p></li><li><p>磁盘调度算法</p><ul><li><p>先来先服务(FCFS)</p></li><li><p>最短寻找时间优先算法(SSTF)</p></li><li><p>扫描算法(SCAN，经典电梯调度算法)</p></li><li><p>循环扫描算法(CSCAN)</p></li></ul></li></ul><h1 id="6-设备管理"><a href="#6-设备管理" class="headerlink" title="6.设备管理"></a>6.设备管理</h1><ul><li><p>基本概念</p><ul><li><p>1&#x2F;0 设备</p></li><li><p>1&#x2F;0 设备分类</p></li></ul></li><li><p>1&#x2F;0 控制</p></li><li><p>缓冲区管理</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习路线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2024/05/02/zhan/"/>
      <url>/2024/05/02/zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="栈的基础介绍"><a href="#栈的基础介绍" class="headerlink" title="栈的基础介绍"></a>栈的基础介绍</h1><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如下图所示，通过常用操作「入栈 push()」,「出栈 pop()」，展示了栈的先入后出特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.push(<span class="number">1</span>); <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.push(<span class="number">2</span>); <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.pop();   <span class="comment">// 出栈 -&gt; 元素 1</span></span><br></pre></td></tr></table></figure><p><img src="/image/zhan/zhan1.webp" alt="zhan1.webp"></p><p>注意：通常情况下，不推荐使用 Java 的 Vector 以及其子类 Stack ，而一般将 LinkedList<br>作为栈来使用。详细说明请见：Stack，ArrayDeque，LinkedList 的区别 。</p><p><img src="/../image/zhan/20190227211326757.webp" alt="20190227211326757.webp"></p><p>底层数据存储方式</p><table><thead><tr><th>名称</th><th>存储方式</th></tr></thead><tbody><tr><td>Stack</td><td>长度为10的数组</td></tr><tr><td>ArrayDeque</td><td>长度为16的数组</td></tr><tr><td>LinkedList</td><td>链表</td></tr></tbody></table><p>1.需要线程同步<br>使用Collections工具类中synchronizedXxx()将线程不同步的ArrayDeque以及LinkedList转换成线程同步。<br>2.频繁的插入、删除操作：LinkedList<br>3.频繁的随机访问操作：ArrayDeque<br>4.未知的初始数据量：LinkedList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">stack.addLast(<span class="number">1</span>);   <span class="comment">// 元素 1 入栈</span></span><br><span class="line">stack.addLast(<span class="number">2</span>);   <span class="comment">// 元素 2 入栈</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 2</span></span><br><span class="line">stack.removeLast(); <span class="comment">// 出栈 -&gt; 元素 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="栈的基本用法"><a href="#栈的基本用法" class="headerlink" title="栈的基本用法"></a>栈的基本用法</h1><ul><li>push(Object item)：将元素item压入栈顶。</li><li>pop()：弹出栈顶元素，并将其从栈中删除。</li><li>peek()：返回栈顶元素，但不删除它。</li><li>isEmpty()：判断栈是否为空，返回布尔值。</li><li>search(Object item)：搜索元素item在栈中的位置（从栈顶开始），如果找到则返回其距离栈顶的位置（栈顶为1），如果未找到则返回-1。</li><li>clear()：对当前栈进行清空。</li></ul><h1 id="栈的几种实现方式"><a href="#栈的几种实现方式" class="headerlink" title="栈的几种实现方式"></a>栈的几种实现方式</h1><h2 id="1-简单的数组实现"><a href="#1-简单的数组实现" class="headerlink" title="1.简单的数组实现"></a>1.简单的数组实现</h2><p>使用简单数组作为底层数据结构来实现栈，通过将栈顶元素的索引存储在变量中，实现压栈和弹栈操作，每次压栈时将元素添加到数组末尾，每次弹栈时将栈顶元素从数组中删除。由于数组的长度是固定的，需要提前定义栈的最大容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (top == stack.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[++top] = item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top--];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基于动态数组的实现方式："><a href="#2-基于动态数组的实现方式：" class="headerlink" title="2.基于动态数组的实现方式："></a>2.基于动态数组的实现方式：</h2><p>使用动态数组（如ArrayList）作为底层数据结构来实现栈，通过在动态数组的尾部进行插入和删除操作来实现栈的功能。当栈容量不足时，动态数组可以自动进行扩容，当栈元素减少时，动态数组可以自动进行缩容。这种实现方式提供了动态调整容量的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; stack;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        stack.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-基于链表的实现方式"><a href="#3-基于链表的实现方式" class="headerlink" title="3.基于链表的实现方式"></a>3.基于链表的实现方式</h2><p>使用链表作为底层数据结构来实现栈，链表的头部或尾部作为栈顶，每次插入和删除操作都在链表的头部进行，通过修改引用来实现栈的操作。链表实现的栈可以动态增加和缩小容量，不需要提前定义栈的最大容量，但相对于数组实现，需要更多的空间开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node top;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">        top = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(item);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            top = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode.next = top;</span><br><span class="line">            top = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-基于数组实现和基于链表实现的比较"><a href="#4-基于数组实现和基于链表实现的比较" class="headerlink" title="4.基于数组实现和基于链表实现的比较"></a>4.基于数组实现和基于链表实现的比较</h2><p>（1）基于数组实现的栈：</p><ul><li><p>各个操作都是常数时间开销</p></li><li><p>每隔一段时间进行的倍增操作的时间开销较大</p></li></ul><p>（2）基于链表实现的栈：</p><ul><li><p>栈规模的增加和减小都很容易</p></li><li><p>各个操作都是常数时间开销</p></li><li><p>每个操作都需要使用额外的空间和时间开销来处理指针</p></li></ul><h2 id="5、基于队列的实现方式："><a href="#5、基于队列的实现方式：" class="headerlink" title="5、基于队列的实现方式："></a>5、基于队列的实现方式：</h2><p>使用队列作为底层数据结构来实现栈，可以使用两个队列来模拟栈的操作。当压栈时，将元素添加到非空队列中；当弹栈时，将非空队列中的元素依次弹出并放入另一个空队列中，直到剩下最后一个元素，即栈顶元素，然后弹出。这种实现方式可以保持栈顶元素总是在队列的尾部，模拟了栈的后进先出（LIFO）特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueBasedStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue1;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue2;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueBasedStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        queue1.add(item);</span><br><span class="line">        top = item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            top = queue1.remove();</span><br><span class="line">            queue2.add(top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue1.remove();</span><br><span class="line">        Queue&lt;Integer&gt; tempQueue = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = tempQueue;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端栈"><a href="#双端栈" class="headerlink" title="双端栈"></a>双端栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>双端栈（Double Ended Stack），也被称为双端队列（Deque），是一种支持在两端进行插入和删除操作的数据结构。它可以在栈顶和栈底执行压栈和弹栈操作，因此既能模拟栈的后进先出（LIFO）特性，又可以模拟队列的先进先出（FIFO）特性。</p><p><img src="/../image/zhan/9a7932c229f1432a81c3ca356aca88f1.png" alt="9a7932c229f1432a81c3ca356aca88f1.png"></p><p>双端栈是线性表的一种,更是栈的一个特殊分类，可用借用动态数组+栈的组合实现</p><p><img src="/../image/zhan/4f5a0c2165f04005aa61ae9d04d1900a.png" alt="4f5a0c2165f04005aa61ae9d04d1900a.png"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>双端栈的特点是可以从两个方向进行操作，即从左侧插入和删除元素，也可以从右侧插入和删除元素。这使得双端栈在某些场景下可以提供更灵活的操作和更高的效率。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是一个使用Java的Deque实现双端栈的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DequeStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; deque;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DequeStack</span><span class="params">()</span> &#123;</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        deque.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.pop();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了Java的Deque，具体是ArrayDeque实现类。ArrayDeque是基于可调整大小的数组实现的双端队列，可以在队列的两端进行插入和删除操作。我们将其作为双端栈的底层数据结构来实现。</p><p>通过双端栈，我们可以在栈顶和栈底进行元素的插入和删除操作。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DequeStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DequeStack</span>();</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(stack.peek()); <span class="comment">// 输出：2</span></span><br><span class="line"> </span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(stack.pop()); <span class="comment">// 输出：4</span></span><br><span class="line"> </span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(stack.pop()); <span class="comment">// 输出：5</span></span><br><span class="line">System.out.println(stack.pop()); <span class="comment">// 输出：3</span></span><br><span class="line">System.out.println(stack.pop()); <span class="comment">// 输出：2</span></span><br><span class="line">System.out.println(stack.isEmpty()); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们将元素依次压栈，并使用peek方法查看栈顶元素。随后，我们连续进行了三次弹栈操作，可以看到栈的后进先出特性。最后，我们通过isEmpty方法验证栈是否为空。</p><p>通过双端栈，我们可以自由地在栈顶和栈底进行操作，根据具体的需求实现不同的功能。</p><h1 id="LeetCode习题实战"><a href="#LeetCode习题实战" class="headerlink" title="LeetCode习题实战"></a>LeetCode习题实战</h1><h2 id="20-有效的括号-简单题"><a href="#20-有效的括号-简单题" class="headerlink" title="20.有效的括号-简单题"></a>20.有效的括号-简单题</h2><table><tr><td bgcolor=#FFFFCD>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。<p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 1：</p><ul><li><p>输入：s &#x3D; “()”</p></li><li><p>输出：true<br>示例 2：</p></li><li><p>输入：s &#x3D; “()[]{}”</p></li><li><p>输出：true<br>示例 3：</p></li><li><p>输入：s &#x3D; “(]”</p></li><li><p>输出：false</p></li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 104</li><li>s 仅由括号 ‘()[]{}’ 组成</td></tr></table></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个栈</span></span><br><span class="line">       LinkedList&lt;Character&gt; stack =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历这个字符串</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">     <span class="comment">//获取i位置的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);   </span><br><span class="line">        <span class="comment">//是左括号就入栈</span></span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            stack.push(ch);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span> || ch == <span class="string">&#x27;&#125;&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//先判空</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出栈判断是否闭合</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>((ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) || (ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) || (ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判空返回就行</span></span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="155-最小栈-简单题"><a href="#155-最小栈-简单题" class="headerlink" title="155.最小栈-简单题"></a>155.最小栈-简单题</h2><table><tr><td bgcolor=#FFFFCD><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul></td></tr></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; mindata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        mindata = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        data.add(val);</span><br><span class="line">        <span class="keyword">if</span>(mindata.isEmpty() || mindata.peek() &gt;= val)&#123;</span><br><span class="line">            mindata.add(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mindata.add(mindata.peek());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty())&#123;</span><br><span class="line">            mindata.pop();</span><br><span class="line">            data.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈中元素为空，此操作非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!mindata.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> mindata.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈中元素为空，此操作非法&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方法很简单–用辅助栈的方式存储同步最小值–也可以设置不同步但是个人觉得同步更简单方便</p><h2 id="394-字符串解码–难题"><a href="#394-字符串解码–难题" class="headerlink" title="394.字符串解码–难题"></a>394.字符串解码–难题</h2><table><tr><td bgcolor=#FFFFCD><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例 1：</p><ul><li><p>输入：s &#x3D; “3[a]2[bc]”</p></li><li><p>输出：”aaabcbc”<br>示例 2：</p></li><li><p>输入：s &#x3D; “3[a2[c]]”</p></li><li><p>输出：”accaccacc”<br>示例 3：</p></li><li><p>输入：s &#x3D; “2[abc]3[cd]ef”</p></li><li><p>输出：”abcabccdcdcdef”<br>示例 4：</p></li><li><p>输入：s &#x3D; “abc3[cd]xyz”</p></li><li><p>输出：”abccdcdcdxyz”</p></li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 30</li><li>s 由小写英文字母、数字和方括号 ‘[]’ 组成</li><li>s 保证是一个 有效 的输入。</li><li>s 中所有整数的取值范围为 [1, 300]</li></ul></td></tr></table><h3 id="解一："><a href="#解一：" class="headerlink" title="解一："></a>解一：</h3><ol><li><p>创建一个字符类型的栈 stack。</p></li><li><p>遍历字符串 s 中的每个字符：</p><ul><li><p>如果字符不是 ‘]’，则将其压入栈中。</p></li><li><p>如果字符是 ‘]’，则执行以下步骤：</p><ul><li><p>取出 ‘[‘ 到 ‘]’ 之间的所有字母，并将其保存在一个字符串 sub 中。</p></li><li><p>移除栈顶的 ‘[‘ 字符。</p></li><li><p>获取 ‘[‘ 前的倍数数字，并将其保存在一个整数 count 中。</p></li><li><p>根据倍数将 sub 中的字母重新放入栈中。</p></li></ul></li></ul></li><li><p>将栈中的所有字符取出，并构造出解码后的字符串。</p></li></ol><p>整个过程中，栈 stack 用来存储待解码的字符，通过栈的后进先出特性，可以很方便地处理 ‘[‘ 和 ‘]’ 内的字符。最后将栈中的字符依次取出，并逆序构造出最终的解码后的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c != <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                stack.push(c); <span class="comment">//把所有的字母push进去，除了]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//取出[]内的字符串，就是继续弹出栈直到找到他的边界</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="comment">//不为空并且是字母</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; Character.isLetter(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//这里是一个方法，把弹出的字符插入到字符串的头位置</span></span><br><span class="line">                    sb.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//得到他的字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">                <span class="comment">//此时的栈顶是他的左括号，把左括号删除</span></span><br><span class="line">                stack.pop();</span><br><span class="line"></span><br><span class="line">                sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="comment">//不为空切为数字</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; Character.isDigit(stack.peek()))&#123;</span><br><span class="line">                    sb.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录这个数字，但是数字不一定是个位数且现在是一个字符串，需要解析成为一个int的数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Integer.valueOf(sb.toString());</span><br><span class="line">                <span class="comment">//将找到的[]中的字符以前面count记录的倍数再次压入栈，这样就把一个基本括号的字符压进去，解决每一个括号单位即可</span></span><br><span class="line">                <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> ch : sub.toCharArray())&#123;</span><br><span class="line">                        stack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//倍数计算</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后拿到这个栈里面所有的字符拼接返回即可，---完成！！</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">retv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            retv.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retv.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h3><p>更优解–思路</p><ol><li><p>创建一个 StringBuilder 对象 builder，用于保存解码后的结果。</p></li><li><p>将字符串 s 反转，得到 s1。</p></li><li><p>开始遍历 s1 中的每个字符：</p><ul><li>如果遇到字母或者 ]，将其压入栈 builder 中。</li><li>如果遇到 [，表示一个新的重复段的开始，搜索栈顶最近的 ]，获取 [ ] 之间的字符串，并将 ] 及之后的元素弹出栈。</li><li>如果遇到数字，将其解析为整数 n，然后将 [ ] 之间的字符串重复 n 次并压入栈。</li></ul></li><li><p>最后，将栈 builder 中的元素反转后返回作为解码后的结果。</p></li></ol><p>通过倒序遍历和栈的模拟操作，可以实现字符串的解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 将字符串反转</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> builder.append(s).reverse().toString();</span><br><span class="line">        <span class="comment">// 将builder当作栈</span></span><br><span class="line">        builder = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length() ; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果遇到的是字符或者&#x27;]&#x27;，压入栈</span></span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i)&gt;=<span class="string">&#x27;a&#x27;</span> || s1.charAt(i)==<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                    builder.append(s1.charAt(i));</span><br><span class="line">                <span class="comment">// 如果遇到 &#x27;[&#x27;</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s1.charAt(i)==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                  <span class="comment">// 搜索离栈顶最近的&#x27;]&#x27;</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> builder.lastIndexOf(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="comment">//记录当前栈的高度</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span>  <span class="operator">=</span> builder.toString().length();</span><br><span class="line">                    <span class="comment">// 求得&#x27;[]&#x27; 之间的字符串</span></span><br><span class="line">                    substring = builder.toString().substring(j+<span class="number">1</span>, k);</span><br><span class="line">                    <span class="comment">// 将&#x27;]&#x27;及之后的元素弹出栈</span></span><br><span class="line">                    builder.delete(j,k);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 遇到数字</span></span><br><span class="line">                     <span class="type">StringBuilder</span> <span class="variable">builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="comment">// 数字可能有多位</span></span><br><span class="line">                    <span class="keyword">while</span> (i&lt;s1.length()&amp;&amp; s1.charAt(i)&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s1.charAt(i)&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        builder1.append(s1.charAt(i));</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里要i--,因为for循环还要i++</span></span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> Integer.parseInt(builder1.reverse().toString());</span><br><span class="line">                    <span class="comment">//  将n个&#x27;[]&#x27;之间的字符串压入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (n-- &gt;<span class="number">0</span>)</span><br><span class="line">                        builder.append(substring);</span><br><span class="line">                &#125;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是倒序遍历，所以要反转结果</span></span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="739-每日温度—中等"><a href="#739-每日温度—中等" class="headerlink" title="739.每日温度—中等"></a>739.每日温度—中等</h2><table><tr><td bgcolor=#FFFFCD><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>示例 1:</p><ul><li><p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]</p></li><li><p>输出: [1,1,4,2,1,1,0,0]<br>示例 2:</p></li><li><p>输入: temperatures &#x3D; [30,40,50,60]</p></li><li><p>输出: [1,1,1,0]<br>示例 3:</p></li><li><p>输入: temperatures &#x3D; [30,60,90]</p></li><li><p>输出: [1,1,0]</p></li></ul></td></tr></table><h3 id="方法一–遍历"><a href="#方法一–遍历" class="headerlink" title="方法一–遍历"></a>方法一–遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="comment">//返回的结果数组</span></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    <span class="comment">//思想就是不暴力的话就是减少遍历次数--从后往前遍历--通过后面的数来跳级判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length -<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="comment">//j+= result[j] 利用后面的已经得到的结果跳级</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j+= result[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[j] &gt; temperatures[i])&#123;</span><br><span class="line">                result[i] = j - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二–栈言归正传毕竟是栈的学习（哈哈）"><a href="#方法二–栈言归正传毕竟是栈的学习（哈哈）" class="headerlink" title="方法二–栈言归正传毕竟是栈的学习（哈哈）"></a>方法二–栈言归正传毕竟是栈的学习（哈哈）</h3><p>维护一个存储下标的栈–速度很慢不如上面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temperature</span> <span class="operator">=</span> temperatures[i];</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prevIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        result[prevIndex] = i - prevIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程基础知识</title>
      <link href="/2024/04/30/jinchengxianchengjichu/"/>
      <url>/2024/04/30/jinchengxianchengjichu/</url>
      
        <content type="html"><![CDATA[<h1 id="进程、线程基础知识"><a href="#进程、线程基础知识" class="headerlink" title="进程、线程基础知识"></a>进程、线程基础知识</h1><table><tr><td bgcolor=#FFFFCD>先来看看一则小故事</td></tr></table><p>我们写好的一行行代码，为了让其工作起来，我们还得把它送进城（<font color=#4169E1>进程</font>）里，那既然进了城里，那肯定不能胡作非为了。</p><p>城里人有城里人的规矩，城中有个专门管辖你们的城管（<font color=#4169E1>操作系统</font><br>），人家让你休息就休息，让你工作就工作，毕竟摊位不多，每个人都要占这个摊位来工作，城里要工作的人多着去了。</p><p>所以城管为了公平起见，它使用一种策略（<font color=#4169E1>调度</font>）方式，给每个人一个固定的工作时间（<font color=#4169E1><br>时间片</font>），时间到了就会通知你去休息而换另外一个人上场工作。</p><p>另外，在休息时候你也不能偷懒，要记住工作到哪了，不然下次到你工作了，你忘记工作到哪了，那还怎么继续？</p><p>有的人，可能还进入了县城（<font color=#4169E1>线程</font>）工作，这里相对轻松一些，在休息的时候，要记住的东西相对较少，而且还能共享城里的资源。</p><table><tr><td bgcolor=#FFFFCD>“哎哟，难道本文内容是进程和线程？”</td></tr></table><p>“哎哟，难道本文内容是进程和线程？”</p><p>可以，聪明的你猜出来了，也不枉费我瞎编乱造的故事了。</p><img src="/image/kc.webp" alt="开车" width="300" height="300"><p>进程和线程对于写代码的我们，真的天天见、日日见了，但见的多不代表你就熟悉它们，比如简单问你一句，你知道它们的工作原理和区别吗？</p><p>不知道没关系，今天就要跟大家讨论<font color=#4169E1>操作系统的进程和线程</font>。</p><p><img src="/image/tigang.webp" alt="这是图片" title="提纲"></p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着<br>CPU 会执行程序中的每一条指令，那么这个<font color=#4169E1>运行中的程序，就被称为「进程」（Process）</font>。</p><p>现在我们考虑有一个会读取硬盘文件数据的程序被执行了，那么当运行到读取文件的指令时，就会去从硬盘读取数据，但是硬盘的读写速度是非常慢的，那么在这个时候，如果<br>CPU 傻傻的等硬盘返回数据的话，那 CPU 的利用率是非常低的。</p><p>做个类比，你去煮开水时，你会傻傻的等水壶烧开吗？很明显，小孩也不会傻等。我们可以在水壶烧开之前去做其他事情。当水壶烧开了，我们自然就会听到“嘀嘀嘀”的声音，于是再把烧开的水倒入到水杯里就好了。</p><p>所以，当进程要从硬盘读取数据时，CPU 不需要阻塞等待数据的返回，而是去执行另外的进程。当硬盘数据返回时，CPU 会收到个中断，于是<br>CPU 再继续运行这个进程。</p><p><img src="/image/jcjtyx.webp" alt="这是图片" title="进程与线程交替"></p><p>这种<font color=#4169E1>多个程序、交替执行</font>的思想，就有 CPU 管理多个进程的初步想法。</p><p>对于一个支持多进程的系统，CPU 会从一个进程快速切换至另一个进程，其间每个进程各运行几十或几百个毫秒。</p><p>虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生<font color=#4169E1><br>并行的错觉</font>，实际上这是<font color=#4169E1>并发</font>。<br>并发和并行有什么区别？</p><table><tr><td bgcolor=#FFFFCD>一图胜千言</td></tr></table><p><img src="/image/jcyxcjhczs_1/5-bfybx.webp" alt="这是图片" title="对比图"></p><table><tr><td bgcolor=#FFFFCD>进程与程序的关系的类比</td></tr></table><p>到了晚饭时间，一对小情侣肚子都咕咕叫了，于是男生见机行事，就想给女生做晚饭，所以他就在网上找了辣子鸡的菜谱，接着买了一些鸡肉、辣椒、香料等材料，然后边看边学边做这道菜。<br><img src="/image/zc.webp" alt="这是图片" title="做菜"></p><p>突然，女生说她想喝可乐，那么男生只好把做菜的事情暂停一下，并在手机菜谱标记做到哪一个步骤，把状态信息记录了下来。</p><p>然后男生听从女生的指令，跑去下楼买了一瓶冰可乐后，又回到厨房继续做菜。</p><p>这体现了，CPU 可以从一个进程（做菜）切换到另外一个进程（买可乐），在切换前必须要记录当前进程中运行的状态信息，以备下次切换回来的时候可以恢复执行。</p><p>所以，可以发现进程有着<font color=#4169E1>「运行 - 暂停 - 运行」</font>的活动规律</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>在上面，我们知道了进程有着「运行 - 暂停 - 运行」的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。</p><p>它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。</p><p>所以，<font color=#4169E1>在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。</font></p><p><img src="/image/jcyxcjhczs_1/7-%E8%BF%9B%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.webp" alt="这是图片" title="进程三个基本状态"></p><p>上图中各个状态的意义：</p><ul><li><p>运行状态（Running）：该时刻进程占用 CPU；</p></li><li><p>就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行；</p></li><li><p>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</p></li><li><p>当然，进程还有另外两个基本状态：</p></li><li><p>创建状态（new）：进程正在被创建时的状态；</p></li><li><p>结束状态（Exit）：进程正在从系统中消失时的状态；<br>（依稀记得上课的时候老师提问过，当时我还在查百度，当我去认真学的时候发现其实没有那么难🤡，这里可能有的小伙伴看不懂，详情会继续更新操作系统基础知识，这样可能就理解了）</p></li></ul><p>于是，一个完整的进程状态的变迁如下图：</p><p><img src="/image/jcyxcjhczs_1/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.webp" alt="这是图片" title="进程五个状态"></p><p>再来详细说明一下进程的状态变迁：</p><ul><li>NULL -&gt; 创建状态：一个新进程被创建时的第一个状态；</li><li>创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；</li><li>就绪态 -&gt; 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；</li><li>运行状态 -&gt; 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理；</li><li>运行状态 -&gt; 就绪状态：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；</li><li>运行状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I&#x2F;O 事件；</li><li>阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；<br>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。</li></ul><p>所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。</p><p><img src="/image/jcyxcjhczs_1/9-%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA.webp" alt="这是图片" title="换入换出"></p><p>那么，就需要一个新的状态，来<font color=#4169E1>描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态</font><br>。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回</p><p>另外，挂起状态可以分为两种：</p><ul><li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li><li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li></ul><p>这两种挂起状态加上前面的五种状态，就变成了七种状态变迁（留给我的颜色不多了），见如下图：</p><p><img src="/image/jcyxcjhczs_1/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.webp" alt="这是图片" title="进程七中状态"></p><p>导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：</p><ul><li>通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。</li><li>用户希望挂起一个程序的执行，比如在 Linux 中用 Ctrl+Z 挂起进程（Linux系统是命令行操作系统，感兴趣可以了解一下，后续我也会出Linux系统的笔记）</li></ul><h2 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h2><p>在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程的。</p><p>那 PCB 是什么呢？打开知乎搜索你就会发现这个东西并不是那么简单。</p><p><img src="/image/jcyxcjhczs_1/11-PCB%E5%AB%96%E5%A8%BC.webp" alt="这是图片" title="PCB"></p><p>PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p><table><tr><td bgcolor=#FFFFCD>PCB 具体包含什么信息呢？</td></tr></table><font color=#4169E1>进程描述信息：</font><ul><li><p>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</p></li><li><p>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；<br><font color=#4169E1>进程控制和管理信息：</font></p></li><li><p>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</p></li><li><p>进程优先级：进程抢占 CPU 时的优先级；<br><font color=#4169E1>资源分配清单：</font></p></li><li><p>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。<br><font color=#4169E1>CPU 相关信息：</font></p></li><li><p>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。<br>可见，PCB 包含信息还是比较多的。</p></li></ul><table><tr><td bgcolor=#FFFFCD>每个 PCB 是如何组织的呢？</td></tr></table>通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如：<ul><li>将所有处于就绪状态的进程链在一起，称为就绪队列；</li><li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列；</li><li>另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。<br>那么，就绪队列和阻塞队列链表的组织形式如下图：</li></ul><p><img src="/image/jcyxcjhczs_1/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.webp" alt="这是图片" title="PCB状态链表组织"></p><p>除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。</p><p>一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。</p><h2 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h2><p>我们熟知了进程的状态变迁和进程的数据结构 PCB 后，再来看看进程的<em><strong>创建、终止、阻塞、唤醒</strong></em>的过程，这些过程也就是进程的控制。</p><p><font color=#4169E1>01 创建进程</font></p><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。</p><p>创建进程的过程如下：</p><ul><li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li><li>为该进程分配运行时所必需的资源，比如内存资源；</li><li>将 PCB 插入到就绪队列，等待被调度运行；<br><font color=#4169E1>02 终止进程</font></li></ul><p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 kill 掉）。</p><p>当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由<br>1 号进程对它们完成状态收集工作。</p><p>终止进程的过程如下：</p><ul><li>查找需要终止的进程的 PCB；</li><li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li><li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li><li>将该进程所拥有的全部资源都归还给操作系统；</li><li>将其从 PCB 所在队列中删除；<br><font color=#4169E1>03 阻塞进程</font></li></ul><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p><p>阻塞进程的过程如下：</p><ul><li>找到将要被阻塞进程标识号对应的 PCB；</li><li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li><li>将该 PCB 插入到阻塞队列中去；<br><font color=#4169E1>04 唤醒进程</font></li></ul><p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p><p>如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p><p>唤醒进程的过程如下：</p><ul><li>在该事件的阻塞队列中找到相应进程的 PCB；</li><li>将其从阻塞队列中移出，并置其状态为就绪状态；</li><li>把该 PCB 插入到就绪队列中，等待调度程序调度；<br>进程的阻塞和唤醒是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句。</li></ul><h2 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h2><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个一个进程切换到另一个进程运行，称为进程的上下文切换。</p><table><tr><td bgcolor=#FFFFCD>在详细说进程上下文切换前，我们先来看看 CPU 上下文切换</td></tr></table><p>大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在<br>CPU 运行，于是就造成同时运行的错觉。</p><p>任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。</p><p>所以，操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。</p><p>CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。我举个例子，寄存器像是你的口袋，内存像你的书包，硬盘则是你家里的柜子，如果你的东西存放到口袋，那肯定是比你从书包或家里柜子取出来要快的多。</p><p>再来，程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p><p>所以说，CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。</p><p>既然知道了什么是 CPU 上下文，那理解 CPU 上下文切换就不难了。</p><p>CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p><table><tr><td bgcolor=#FFFFCD>进程的上下文切换到底是切换什么呢？</td></tr></table><p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p><p>所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p><p>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU<br>中，这使得这个进程可以继续执行，如下图所示：</p><p><img src="/image/jcyxcjhczs_1/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.webp" alt="这是图片" title="进程上下文切换"></p><p>大家需要注意，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。</p><table><tr><td bgcolor=#FFFFCD>发生进程上下文切换有哪些场景？</td></tr></table><ul><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；<br>以上，就是发生进程上下文切换的常见场景了（具体怎么调度后面调度会讲）</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是线程。</p><h2 id="为什么使用线程？"><a href="#为什么使用线程？" class="headerlink" title="为什么使用线程？"></a>为什么使用线程？</h2><p>我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：</p><ul><li>从视频文件当中读取数据；</li><li>对读取的数据进行解压缩；</li><li>把解压缩后的视频数据播放出来；<br>对于单进程的实现方式，我想大家都会是以下这个方式：</li></ul><p><img src="/image/jcyxcjhczs_1/14-%E5%8D%95%E7%BA%BF%E7%A8%8Bmp4%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B.webp" alt="这是图片" title="单线程mp4代码实例"></p><p>对于单进程的这种方式，存在以下问题：</p><ul><li>播放出来的画面和声音会不连贯，因为当 CPU 能力不够强的时候，Read 的时候可能进程就等在这了，这样就会导致等半天才进行数据解压和播放；</li><li>各个函数之间不是并发执行，影响资源的使用效率；<br>那改进成多进程的方式：</li></ul><p><img src="/image/jcyxcjhczs_1/15-%E5%A4%9A%E8%BF%9B%E7%A8%8Bmp4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B.webp" alt="这是图片" title="多进程mp4-代码实例"></p><p>对于多进程的这种方式，依然会存在问题：</p><ul><li><p>进程之间如何通信，共享数据？</p></li><li><p>维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；<br>那到底如何解决呢？需要有一种新的实体，满足以下特性：</p></li><li><p>实体之间可以并发运行；</p></li><li><p>实体之间共享相同的地址空间；<br>这个新的实体，就是**<em>线程( Thread )</em>**，线程之间可以并发运行且共享相同的地址空间。</p></li></ul><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><p>线程是进程当中的一条执行流程。</p><p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p><img src="/image/jcyxcjhczs_1/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.webp" alt="这是图片" title="多线程内存结构"></p><table><tr><td bgcolor=#FFFFCD>线程的优缺点？</td></tr></table>线程的优点：<ul><li><p>一个进程中可以同时存在多个线程；</p></li><li><p>各个线程之间可以并发执行；</p></li><li><p>各个线程之间可以共享地址空间和文件等资源；<br>线程的缺点：</p></li><li><p>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C&#x2F;C++ 语言，Java语言中的线程奔溃不会造成进程崩溃。）<br>举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。</p></li></ul><h2 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h2><p>线程与进程的比较如下：</p><ul><li><p>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</p></li><li><p>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</p></li><li><p>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</p></li><li><p>线程能减少并发执行的时间和空间开销；<br>对于，线程相比进程能减少开销，体现在：</p></li><li><p>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</p></li><li><p>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</p></li><li><p>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</p></li><li><p>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；<br>所以，不管是时间效率，还是空间效率线程比进程都要高。</p></li></ul><h2 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h2><p>在前面我们知道了，线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。</p><p>所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>对于线程和进程，我们可以这么理解：</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程；</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；<br>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li></ul><table><tr><td bgcolor=#FFFFCD>线程上下文切换的是什么？</td></tr></table>这还得看线程是不是属于同一个进程：<ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；<br>所以，线程的上下文切换相比进程，开销要小很多。</li></ul><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>主要有三种线程的实现方式：</p><ul><li>用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li><li>内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；</li><li>轻量级进程（LightWeight Process）：在内核中来支持用户线程；<br>那么，这还需要考虑一个问题，用户线程和内核线程的对应关系。</li></ul><p>首先，第一种关系是多对一的关系，也就是多个用户线程对应同一个内核线程：</p><p><img src="/image/jcyxcjhczs_1/17-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.webp" alt="这是图片" title="内核线程与用户线程-一对多关系"></p><p>第二种是一对一的关系，也就是一个用户线程对应一个内核线程：</p><p><img src="/image/jcyxcjhczs_1/18-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.webp" alt="这是图片" title="一对一"></p><p>第三种是多对多的关系，也就是多个用户线程对应到多个内核线程：</p><p><img src="/image/jcyxcjhczs_1/19-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.webp" alt="这是图片" title="一对多"></p><table><tr><td bgcolor=#FFFFCD>用户线程如何理解？存在什么优势和缺陷？</td></tr></table>用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。<p>所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</p><p>用户级线程的模型，也就类似前面提到的多对一的关系，即多个用户线程对应同一个内核线程，如下图所示：</p><p><img src="/image/jcyxcjhczs_1/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.webp" alt="这是图片" title="一对多"></p><p>用户线程的优点：</p><ul><li><p>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB<br>由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</p></li><li><p>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；<br>用户线程的缺点：</p></li><li><p>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</p></li><li><p>当一个线程开始运行后，除非它主动地交出 CPU<br>的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。</p></li><li><p>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；<br>以上，就是用户线程的优缺点了。</p></li></ul><table><tr><td bgcolor=#FFFFCD>那内核线程如何理解？存在什么优势和缺陷？</td></tr></table>内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。<p>内核线程的模型，也就类似前面提到的一对一的关系，即一个用户线程对应一个内核线程，如下图所示：</p><p><img src="/image/jcyxcjhczs_1/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.webp" alt="这是图片" title="一对一"></p><p>内核线程的优点：</p><ul><li><p>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</p></li><li><p>分配给线程，多线程的进程获得更多的 CPU 运行时间；<br>内核线程的缺点：</p></li><li><p>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；</p></li><li><p>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；<br>以上，就是内核线程的优缺点了。</p></li><li><table><tr><td bgcolor=#FFFFCD>最后的轻量级进程如何理解？</td></tr></table></li></ul><p>轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是<br>LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。</p><p>在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程代表程序的一个实例，而<br>LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。</p><p>在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：</p><ul><li>1 : 1，即一个 LWP 对应 一个用户线程；</li><li>N : 1，即一个 LWP 对应多个用户线程；</li><li>M : N，即多个 LWP 对应多个用户线程；<br>接下来针对上面这三种对应关系说明它们优缺点。先看下图的 LWP 模型：</li></ul><p><img src="/image/jcyxcjhczs_1/22-LWP.webp" alt="这是图片" title="LWP"></p><p><strong>1 : 1 模式</strong></p><p>一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。</p><p>优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；<br>缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。<br><strong>N : 1 模式</strong></p><p>多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。</p><p>优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；<br>缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。<br><strong>M : N 模式</strong></p><p>根据前面的两个模型混搭一起，就形成 M:N 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程<br>3。</p><p>优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。<br><strong>组合模式</strong></p><p>如上图的进程 5，此进程结合 1:1 模型和 M:N 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案</p><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。</p><p>一旦操作系统把进程切换到运行状态，也就意味着该进程占用着 CPU 在执行，但是当操作系统把进程切换到其他状态时，那就不能在 CPU<br>中执行了，于是操作系统会选择下一个要运行的进程。</p><p>选择一个进程运行这一功能是在操作系统中完成的，通常称为调度程序（scheduler）。</p><p>那到底什么时候调度进程，或以什么原则来调度进程呢？</p><p>TIP</p><p>很多人会问，线程不是操作系统的调度单位吗？为什么这里参与调度的是进程？</p><p>先提前说明，这里的进程指只有主线程的进程，所以调度主线程就等于调度了整个进程。</p><p>那为什么干脆不直接取名线程调度？主要是操作系统相关书籍，都是用进程调度这个名字，所以这里也沿用了这个名字。</p><h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p><p>比如，以下状态的变化都会触发操作系统的调度：</p><ul><li><strong>从就绪态 -&gt; 运行态</strong>：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；</li><li><strong>从运行态 -&gt; 阻塞态</strong>：当进程发生 I&#x2F;O 事件而阻塞时，操作系统必须选择另外一个进程运行；</li><li><strong>从运行态 -&gt; 结束态</strong>：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；<br>因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运行，或者是否让当前进程从 CPU 上退出来而换另一个进程运行。</li></ul><p>另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：</p><ul><li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li><li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<br><strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong></li></ul><h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><p>原则一：如果运行的程序，发生了 I&#x2F;O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成<br>CPU 突然的空闲。所以，为了提高 CPU 利用率，在这种发送 I&#x2F;O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</p><p>原则二：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU<br>在单位时间内完成的进程数量）的降低。所以，要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</p><p>原则三：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</p><p>原则四：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU<br>中执行。所以，就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</p><p>原则五：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</p><p><img src="/image/jcyxcjhczs_1/23-%E4%BA%94%E7%A7%8D%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99.webp" alt="这是图片" title="五种调度规则"></p><p>针对上面的五种调度原则，总结成如下：</p><ul><li>CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li><li>系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li><li>周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</li><li>等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li><li>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。<br>说白了，这么多调度原则，目的就是要使得进程要「快」</li></ul><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>不同的调度算法适用的场景也是不同的。</p><p>接下来，说说在单核 CPU 系统中常见的调度算法。</p><table><tr><td bgcolor=#FFFFCD>01 先来先服务调度算法</td></tr></table><p>最简单的一个调度算法，就是非抢占式的先来先服务（First Come First Serve, FCFS）算法了</p><p><img src="/image/jcyxcjhczs_1/24-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.webp" alt="这是图片" title="FCFS"></p><p>顾名思义，先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</p><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p><table><tr><td bgcolor=#FFFFCD>02 最短作业优先调度算法</td></tr></table><p>最短作业优先（Shortest Job First, SJF）调度算法同样也是顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。</p><p><img src="/image/jcyxcjhczs_1/25-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.webp" alt="这是图片" title="SJF"></p><p>这显然对长作业不利，很容易造成一种极端现象。</p><p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><table><tr><td bgcolor=#FFFFCD>03 高响应比优先调度算法</td></tr></table>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。<p>那么，高响应比优先 （Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。</p><p>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：</p><p><img src="/image/jcyxcjhczs_1/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.webp" alt="这是图片" title="HRRN"></p><p>从上面的公式，可以发现：</p><ul><li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li><li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；<br>TIP</li></ul><p>很多人问怎么才能知道一个进程要求服务的时间？这不是不可预知的吗？</p><p>对的，这是不可预估的。所以，高响应比优先调度算法是「理想型」的调度算法，现实中是实现不了的。</p><table><tr><td bgcolor=#FFFFCD>04 时间片轮转调度算法</td></tr></table><p>最古老、最简单、最公平且使用最广的算法就是时间片轮转（Round Robin, RR）调度算法。</p><p><img src="/image/jcyxcjhczs_1/27-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%AF%A2.webp" alt="这是图片" title="RR"></p><p>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</p><ul><li><p>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</p></li><li><p>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；<br>另外，时间片的长度就是一个很关键的点：</p></li><li><p>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</p></li><li><p>如果设得太长又可能引起对短作业进程的响应时间变长。将<br>一般来说，时间片设为 20ms~50ms 通常是一个比较合理的折中值。</p></li></ul><table><tr><td bgcolor=#FFFFCD>05 最高优先级调度算法</td></tr></table><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。</p><p>进程的优先级可以分为，静态优先级和动态优先级：</p><ul><li><p>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</p></li><li><p>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。<br>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p></li><li><p>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</p></li><li><p>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。<br>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p></li><li><table><tr><td bgcolor=#FFFFCD>06 多级反馈队列调度算法</td></tr></table></li></ul><p>多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><p><img src="/image/jcyxcjhczs_1/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.webp" alt="这是图片" title="多级队列"></p><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；<br>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。</li></ul><table><tr><td bgcolor=#FFFFCD>看的迷迷糊糊？那我拿去银行办业务的例子，把上面的调度算法串起来，你还不懂，你锤我！</td></tr></table><p>办理业务的客户相当于进程，银行窗口工作人员相当于 CPU。</p><p>现在，假设这个银行只有一个窗口（单核 CPU ），那么工作人员一次只能处理一个业务。</p><p><img src="/image/jcyxcjhczs_1/29-%E9%93%B6%E8%A1%8C1V1.webp" alt="这是图片" title="银行"></p><p>那么最简单的处理方式，就是先来的先处理，后面来的就乖乖排队，这就是先来先服务（FCFS）调度算法。但是万一先来的这位老哥是来贷款的，这一谈就好几个小时，一直占用着窗口，这样后面的人只能干等，或许后面的人只是想简单的取个钱，几分钟就能搞定，却因为前面老哥办长业务而要等几个小时，你说气不气人？</p><p><img src="/image/jcyxcjhczs_1/30-%E9%93%B6%E8%A1%8C-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.webp" alt="这是图片" title="银行"></p><p>有客户抱怨了，那我们就要改进，我们干脆优先给那些几分钟就能搞定的人办理业务，这就是短作业优先（SJF）调度算法。听起来不错，但是依然还是有个极端情况，万一办理短业务的人非常的多，这会导致长业务的人一直得不到服务，万一这个长业务是个大客户，那不就捡了芝麻丢了西瓜</p><p><img src="/image/jcyxcjhczs_1/31-%E9%93%B6%E8%A1%8C-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88.webp" alt="这是图片" title="银行"></p><p>那就公平起见，现在窗口工作人员规定，每个人我只处理 10 分钟。如果 10 分钟之内处理完，就马上换下一个人。如果没处理完，依然换下一个人，但是客户自己得记住办理到哪个步骤了。这个也就是时间片轮转（RR）调度算法。但是如果时间片设置过短，那么就会造成大量的上下文切换，增大了系统开销。如果时间片过长，相当于退化成 FCFS 算法了。</p><p><img src="/image/jcyxcjhczs_1/32-%E9%93%B6%E8%A1%8C-%E6%97%B6%E9%97%B4%E8%AE%BA%E7%89%87.webp" alt="这是图片" title="银行"></p><p>既然公平也可能存在问题，那银行就对客户分等级，分为普通客户、VIP 客户、SVIP 客户。只要高优先级的客户一来，就第一时间处理这个客户，这就是最高优先级（HPF）调度算法。但依然也会有极端的问题，万一当天来的全是高级客户，那普通客户不是没有被服务的机会，不把普通客户当人是吗？那我们把优先级改成动态的，如果客户办理业务时间增加，则降低其优先级，如果客户等待时间增加，则升高其优先级。</p><p><img src="/image/jcyxcjhczs_1/33-%E9%93%B6%E8%A1%8C-%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7.webp" alt="这是图片" title="银行"></p><p>那有没有兼顾到公平和效率的方式呢？这里介绍一种算法，考虑的还算充分的，多级反馈队列（MFQ）调度算法，它是时间片轮转算法和优先级算法的综合和发展。它的工作方式：</p><p><img src="/image/jcyxcjhczs_1/34-%E9%93%B6%E8%A1%8C-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88.webp" alt="这是图片" title="银行"></p><p>银行设置了多个排队（就绪）队列，每个队列都有不同的优先级，各个队列优先级从高到低，同时每个队列执行时间片的长度也不同，优先级越高的时间片越短。<br>新客户（进程）来了，先进入第一级队列的末尾，按先来先服务原则排队等待被叫号（运行）。如果时间片用完客户的业务还没办理完成，则让客户进入到下一级队列的末尾，以此类推，直至客户业务办理完成。<br>当第一级队列没人排队时，就会叫号二级队列的客户。如果客户办理业务过程中，有新的客户加入到较高优先级的队列，那么此时办理中的客户需要停止办理，回到原队列的末尾等待再次叫号，因为要把窗口让给刚进入较高优先级队列的客户。<br>可以发现，对于要办理短业务的客户来说，可以很快的轮到并解决。对于要办理长业务的客户，一下子解决不了，就可以放到下一个队列，虽然等待的时间稍微变长了，但是轮到自己的办理时间也变长了，也可以接受，不会造成极端的现象，可以说是综合上面几种算法的优点。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统，学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2024/04/30/test/"/>
      <url>/2024/04/30/test/</url>
      
        <content type="html"><![CDATA[<h2 id="作为测试文章使用记录文章用法"><a href="#作为测试文章使用记录文章用法" class="headerlink" title="作为测试文章使用记录文章用法"></a>作为测试文章使用记录文章用法</h2><h3 id="1-1-test"><a href="#1-1-test" class="headerlink" title="1.1 test"></a>1.1 test</h3><p>无序列表:</p><ul><li>列表内容, </li><li>列表内容, </li><li>列表内容,</li></ul><p><code>高亮</code>文字</p><table><tr><td bgcolor=DarkSeaGreen>这里的背景色是：DarkSeaGreen，此处输入任意想输入的内容</td></tr></table><p>cornsilk</p><table><tr><td bgcolor=#FFF8DC>背景色orange</td></tr></table><p>白杏仁</p><table><tr><td bgcolor=#FFFFCD>背景色orange</td></tr></table><p>淡黄色</p><table><tr><td bgcolor=#F5DEB3>背景色orange</td></tr></table><p><img src="/image/kc.webp" alt="这是图片" title="Magic Gardens"></p><img src="/image/kc.webp" alt="开车" width="300" height="300"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是 JavaScript 代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/29/hello-world/"/>
      <url>/2024/04/29/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World–程序员的浪漫"><a href="#Hello-World–程序员的浪漫" class="headerlink" title="Hello World–程序员的浪漫"></a>Hello World–程序员的浪漫</h1><p>如果用英文直译，“hello,world”很容易能翻译出一个“你好，世界”。但是要理解这个梗的起源和真正含义的话，这就要说回每个程序猿，为代码熬过的夜，掉的越来越多的头发。</p><p>在程序员还仅仅是个程序菜鸟，刚刚做好准备探寻奥秘无限的代码世界时，无论TA初学的是哪种编程语言——是C还是php，python 还是java…</p><p><strong><em>（LdwZs接触的第一个编程语言就是C语言，陆续接触过Java，python，js，Ts，C++等，在追寻自己学习目标的道路上也是一路坎坷–接触每一个语言的最初输出“hello,world”，想想当时都是兴奋的）</em></strong></p><p>TA手指兴奋地在键盘上敲打出的，TA人生中的第一个程序，一定就是“hello,world”。</p><p>准确的来说，是写一段程序，然后运行这个程序的作用，就是在命令行（或者弹窗）里显示出这句“hello,world”。</p><p>这句话的历史由来，是在1978年，Brian Kernighan大佬在《C 程序设计语言》这本在程序员中广泛传播的教程书里，作为开篇第一个程序写下的：</p><p>由于它的易用性，“hello,world”也广泛用于各种学习新语言之后的调试场景：</p><p>虽然现在，只能依靠我们编写程序让机器说出这句话；</p><p>但或许将来有一天，世界上会真的诞生拥有自主思考能力的人工智能。</p><p>那时，程序员手下的程序就会真正拥有生命，会通过自己的思考，了解人类所生活的世界，并且说出这一句“hello, world！”</p><p>或许到了那时，有人会对这种感到恐惧、忌惮和不信任，但不可否认的是，真正的AI——那真的会是，一个无比伟大和浪漫的技术奇迹。</p><p>本篇文章作为该Blog的开山文章吧，内容部分出自百度，这篇文章也是我的Biog的“hello,world”</p>]]></content>
      
      
      <categories>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
